/*
 * ParchisPanel.java
 *
 * Created on 01-ene-2010, 23:19:41
 */

package parchis.studio;

import java.awt.BasicStroke;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.*;
import parchis.*;
import static parchis.Color.*;
import static parchis.Cell.*;


/**
 *
 * @author sortega
 */
public class ParchisPanel extends javax.swing.JPanel {


    /** Creates new form ParchisPanel */
    public ParchisPanel(Pawns pawns) {
        this.pawns = pawns;
        initComponents();
    }

    public void setPawns(Pawns pawns) {
        this.pawns = pawns;
        this.repaint();
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        formComponentResized(null); // TODO: why I need this line?

        Graphics2D g = (Graphics2D) graphics;
        super.paintComponent(g);

        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        paintBoard(g);
        if (pawns != null) {
            paintPawns(g);
        }

    }

    private void paintBoard(Graphics2D g) {
        g.setColor(java.awt.Color.WHITE);
        g.fillRect(0, 0, (int) boardLength, (int) boardLength);
        g.setFont(new Font("verdana", Font.PLAIN, 10));

        for (parchis.Color player: ALL_PLAYERS) {
            paintPlayerSquare(g, player);
        }
        for (Cell pos : ALL_CELLS) {
            paintCell(g, pos);
        }
    }
    

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setName("Form"); // NOI18N
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        this.boardLength = Math.min(this.getWidth(), this.getHeight());
        this.cellHeight = boardLength / 21;
        this.cellWidth = cellHeight * 2;
        this.pawnLength = cellHeight * 0.7f;
    }//GEN-LAST:event_formComponentResized

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        formComponentResized(evt);
    }//GEN-LAST:event_formComponentShown

    private void paintPlayerSquare(Graphics2D g, parchis.Color player) {

        double radious = 0.7 * 4 * cellHeight;
        Shape square = new Rectangle2D.Double(4 * cellHeight - radious,
                4 * cellHeight - radious , 2 * radious, 2 * radious);
        square = rotate(square, playerRotation(player));

        g.setColor(CELL_COLOR.get(player));
        g.fill(square);
        g.setColor(java.awt.Color.black);
        g.draw(square);

        radious = 0.5 * 4 * cellHeight;
        square = new Rectangle2D.Double(4 * cellHeight - radious,
                4 * cellHeight - radious , 2 * radious, 2 * radious);
        square = rotate(square, playerRotation(player));

        g.draw(square);
    }


    private void paintCell(Graphics2D g, Cell cell) {
        Shape cellShape = getCellShape(cell);
        Rectangle2D cellRect = cellShape.getBounds2D();

        if (cell.getColor() == null) {
            if (cell.isHome()) {
                Color player = Color.values()[(cell.getNumber() - 1) / 17];
                g.setColor(CELL_COLOR.get(player));
                g.fill(cellShape);
            } else if (cell.isShelter()) {
                g.setColor(SHELTER_COLOR);
                g.fill(cellShape);
            }
            g.setColor(java.awt.Color.black);
            g.setStroke(CELL_STROKE);
            drawCenteredText(g, Integer.toString(cell.getNumber()), cellRect);
            g.draw(cellShape);

        } else  { // Private path
            g.setColor(CELL_COLOR.get(cell.getColor()));
            g.fill(cellShape);
            g.setColor(java.awt.Color.black);
            g.setStroke(CELL_STROKE);
            g.draw(cellShape);
        }
    }

    private Shape getCellShape(Cell cell) {
        Shape shape;
        double rotation;

        /*
         * Calculate cell center for cells translated to the range 1-17,
         * then translate back
         */
        if (cell.getColor() == null) {
            rotation = -((cell.getNumber() - 1) / 17) * Math.PI / 2;

            int equivNumber = equivCellNumber(cell.getNumber());
            if (equivNumber < 8) {
                shape = new Rectangle2D.Float(
                        boardLength / 2 - 1.5f * cellWidth,
                        cellHeight * (equivNumber - 1),
                        cellWidth, cellHeight);

            } else if (equivNumber == 8) {
                double[] xs = new double[] {
                    boardLength / 2 - 1.75f * cellWidth,
                    boardLength / 2 - 0.5f * cellWidth,
                    boardLength / 2 - 0.5f * cellWidth,
                    boardLength / 2 - 1.25f * cellWidth,
                };
                double[] ys = new double[] {
                    cellHeight * (equivNumber - 1),
                    cellHeight * (equivNumber - 1),
                    cellHeight *  equivNumber,
                    cellHeight *  equivNumber,
                };

                shape = polygon(xs, ys, 4);

            } else if (equivNumber == 9) {
                double[] xs = new double[] {
                    (16f - equivNumber) * cellHeight,
                    (17f - equivNumber) * cellHeight,
                    (17f - equivNumber) * cellHeight,
                    (16f - equivNumber) * cellHeight,
                };
                double[] ys = new double[] {
                    boardLength / 2 - 1.75f * cellWidth,
                    boardLength / 2 - 1.25f * cellWidth,
                    boardLength / 2 - 0.5f * cellWidth,
                    boardLength / 2 - 0.5f * cellWidth,
                };

                shape = polygon(xs, ys, 4);

            } else if(equivNumber <= 16) {
                shape = new Rectangle2D.Float(
                        (16f - equivNumber) * cellHeight,
                        boardLength / 2 - 1.5f * cellWidth,
                        cellHeight, cellWidth);

            } else { // cell 17
                shape = new Rectangle2D.Float(
                        0,
                        (boardLength - cellWidth) / 2,
                        cellHeight, cellWidth);
            }


        } else { // Private path
            rotation = -cell.getColor().ordinal() * Math.PI / 2;

            if (cell.isGoal()) {
                double[] xs = new double[] {
                    boardLength / 2 - 1.25 * cellWidth,
                    boardLength / 2,
                    boardLength / 2 + 1.25 * cellWidth
                };
                double[] ys = new double[] {
                    cell.getNumber() * cellHeight,
                    boardLength / 2,
                    cell.getNumber() * cellHeight,
                };

                shape = polygon(xs, ys, 3);

            } else {
                shape = new Rectangle2D.Float(
                        (boardLength - cellWidth) / 2,
                        cell.getNumber() * cellHeight,
                        cellWidth, cellHeight);
            }
        }

        return rotate(shape, rotation);
    }

    /**
     * List of pawn centers for a given cell.
     * @return
     */
    private List<Point2D> getPawnPlacements(Cell cell, int pawnNumber) {
        Cell equivCell = equivCell(cell);
        Rectangle2D bounds = getCellShape(equivCell).getBounds2D();
        Point2D center = new Point2D.Double(
                (bounds.getMaxX() + bounds.getMinX()) / 2,
                (bounds.getMaxY() + bounds.getMinY()) / 2);

        List<Point2D> equivPlacements = new ArrayList<Point2D>();
        if (pawnNumber == 1) {
            equivPlacements.add(center);

        } else {

            if (cell.isGoal()) {
                equivPlacements.add(new Point2D.Double(center.getX() - 0.25 * cellWidth, center.getY() - 0.4 * cellWidth));
                equivPlacements.add(new Point2D.Double(center.getX() - 0.25 * cellWidth, center.getY()));
                equivPlacements.add(new Point2D.Double(center.getX() + 0.25 * cellWidth, center.getY() - 0.4 * cellWidth));
                equivPlacements.add(new Point2D.Double(center.getX() + 0.25 * cellWidth, center.getY()));

            } else if (cell.getColor() != null || equivCell.getNumber() < 8) {
                equivPlacements.add(new Point2D.Double(center.getX() - 0.25 * cellWidth, center.getY()));
                equivPlacements.add(new Point2D.Double(center.getX() + 0.25 * cellWidth, center.getY()));

            } else if (cell.getColor() == null && equivCell.getNumber() == 8) {
                equivPlacements.add(new Point2D.Double(center.getX() - 0.1 * cellWidth, center.getY()));
                equivPlacements.add(new Point2D.Double(center.getX() + 0.4 * cellWidth, center.getY()));

            } else if (cell.getColor() == null && equivCell.getNumber() == 9) {
                equivPlacements.add(new Point2D.Double(center.getX(), center.getY() - 0.1 * cellWidth));
                equivPlacements.add(new Point2D.Double(center.getX(), center.getY() + 0.4 * cellWidth));

            } else {
                equivPlacements.add(new Point2D.Double(center.getX(), center.getY() - 0.25 * cellWidth));
                equivPlacements.add(new Point2D.Double(center.getX(), center.getY() + 0.25 * cellWidth));
            }
        }

        List<Point2D> placements = new ArrayList<Point2D>();
        double rotation = equivRotation(cell);
        for (Point2D equivPlacement: equivPlacements) {
            placements.add(rotate(equivPlacement, rotation));
        }
        return placements;
    }

    private void drawCenteredText(Graphics2D g, String text, Rectangle2D rect) {
        Rectangle2D bounds = g.getFont().getStringBounds(text, g.getFontRenderContext());
        FontMetrics fm = g.getFontMetrics();
        g.drawString(text,
                (float) (rect.getX() + (rect.getWidth() - bounds.getWidth()) / 2),
                (float) (rect.getY() + (rect.getHeight() - bounds.getHeight()) / 2 + fm.getAscent()));
    }

    private Shape rotate(Shape p, double rotation) {
        AffineTransform transform = AffineTransform.getTranslateInstance(boardLength / 2, boardLength / 2);
        transform.concatenate(AffineTransform.getRotateInstance(rotation));
        transform.concatenate(AffineTransform.getTranslateInstance(-boardLength / 2, -boardLength / 2));

        GeneralPath path = new GeneralPath();
        path.append(p.getPathIterator(transform), true);
        return path;
    }

    private Point2D rotate(Point2D p, double rotation) {
        AffineTransform transform = AffineTransform.getTranslateInstance(boardLength / 2, boardLength / 2);
        transform.concatenate(AffineTransform.getRotateInstance(rotation));
        transform.concatenate(AffineTransform.getTranslateInstance(-boardLength / 2, -boardLength / 2));

        Point2D r = new Point2D.Double();
        transform.transform(p, r);
        return r;
    }

    private void paintPawns(Graphics2D g) {
        for (Color player: Color.ALL_PLAYERS) {
            for (int i=0; i<Pawns.MAX_PAWNS - pawns.getPlayerPawnCount(player); i++) {
                // draw pawn out of game
            }
        }

        for (Cell pos: Cell.ALL_CELLS) {
            List<Color> cellPawns = pawns.getPawnsIn(pos);

            if(!cellPawns.isEmpty()) {
                List<Point2D> centers = getPawnPlacements(pos, cellPawns.size());

                Iterator<Point2D> centerIt = centers.iterator();
                Iterator<Color> pawnIt = cellPawns.iterator();
                while (pawnIt.hasNext()) {
                    drawPawn(g, centerIt.next(), pawnIt.next());
                }
            }
        }
    }


    private void drawPawn(Graphics2D g, Point2D center, Color player) {
        Ellipse2D circle = new Ellipse2D.Double(center.getX() - pawnLength /2,
                center.getY() - pawnLength / 2, pawnLength, pawnLength);
        g.setColor(PAWN_COLOR.get(player));
        g.fill(circle);
        g.setColor(java.awt.Color.black);
        g.setStroke(new BasicStroke(1.5f));
        g.draw(circle);
    }


    private static final Map<Color, java.awt.Color> CELL_COLOR =
            new EnumMap<Color, java.awt.Color>(Color.class);
    static {
        CELL_COLOR.put(Color.yellow, new java.awt.Color(1f, 1f, 0.3f));
        CELL_COLOR.put(Color.blue, new java.awt.Color(0.3f, 0.3f, 1f));
        CELL_COLOR.put(Color.red, new java.awt.Color(1f, 0.3f, 0.3f));
        CELL_COLOR.put(Color.green, new java.awt.Color(0.3f, 1f, 0.3f));
    }

    private static final Map<Color, java.awt.Color> PAWN_COLOR =
            new EnumMap<Color, java.awt.Color>(Color.class);
    static {
        PAWN_COLOR.put(Color.yellow, java.awt.Color.yellow);
        PAWN_COLOR.put(Color.blue, java.awt.Color.blue);
        PAWN_COLOR.put(Color.red, java.awt.Color.red);
        PAWN_COLOR.put(Color.green, java.awt.Color.green);
    }

    private static final java.awt.Color SHELTER_COLOR = new java.awt.Color(0.8f, 0.8f, 0.8f);
    private static final BasicStroke CELL_STROKE =
            new BasicStroke(1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);


    private float boardLength;
    private float pawnLength;
    private float cellHeight;
    private float cellWidth;
    private Pawns pawns;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables


    private static Cell equivCell(Cell cell) {
        if (cell.getColor() != null) {
            return new Cell(Color.yellow, cell.getNumber());
        } else {
            return new Cell(null, equivCellNumber(cell.getNumber()));
        }
    }


    private static int equivCellNumber(int number) {
        return (number - 1) % 17 + 1;
    }

    
    private static double equivRotation(Cell cell) {
        if (cell.getColor() == null) {
            return -((cell.getNumber() - 1) / 17) * Math.PI / 2;
        } else {
            return playerRotation(cell.getColor());
        }
    }

    private static double playerRotation(Color player) {
        return -player.ordinal() * Math.PI / 2;
    }

    private static Shape polygon(double[] xs, double[] ys, int points) {
        GeneralPath path = new GeneralPath();

        path.moveTo(xs[0], xs[0]);
        for (int i=1; i<points; i++) {
            path.lineTo(xs[i], ys[i]);
        }
        path.closePath();

        return path;
    }
}
